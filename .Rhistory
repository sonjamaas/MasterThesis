} else if (Diameter_noBark > 0.59 & Diameter_noBark <= 0.69) {
diameter_class <- "6"
} else if (Diameter_noBark > 0.69 & Diameter_noBark <= 0.79) {
diameter_class <- "7"
} else {
diameter_class <- "8"
}
}
### 2.6 Function to check if points are within a cylinder
points_in_cylinder <- function(points, start, end, max_radius,
min_radius, buffer = 0) {
# Vector along axis
axis_vec <- end - start
axis_len <- sqrt(sum(axis_vec^2))
if (axis_len < 1e-6)
return(rep(FALSE, nrow(points))) # skip degenerate
axis_unit <- axis_vec / axis_len
v <- sweep(points, 2, start) # points - start
t_proj <- v %*% axis_unit    # projection along axis
# Points within the length of the cylinder
mask_length <- (t_proj >= 0) & (t_proj <= axis_len)
# Closest point on axis to each point
closest <- sweep(matrix(t_proj, ncol = 1) %*% t(axis_unit), 2, start, "+")
dist_to_axis <- sqrt(rowSums((points - closest)^2))
mask_radius <- (dist_to_axis > (min_radius + buffer)) &
(dist_to_axis <= (max_radius + buffer))
mask <- mask_length & mask_radius
return(mask)
}
### 2.7 Function to find the fitting cylinder for a point
find_cylinder_for_point <- function(point, qsm_table) {
p <- as.numeric(point)
for (i in 1:nrow(qsm_table)) {
# Cylinder axis
start <- as.numeric(qsm_table[i, c("startX", "startY", "startZ")])
end   <- as.numeric(qsm_table[i, c("endX", "endY", "endZ")])
radius <- qsm_table[i, "radius_cyl"]
# Vector from start to end
axis_vec <- end - start
axis_len <- sqrt(sum(axis_vec^2))
axis_dir <- axis_vec / axis_len
if (axis_len < 1e-6)
return(rep(FALSE, nrow(points))) # skip degenerate
# Vector from start to point
v <- as.numeric(point) - start
proj_len <- sum(v * axis_dir)
# Check if projection is within cylinder segment
if (proj_len >= 0 && proj_len <= axis_len) {
# Closest point on axis
closest <- start + proj_len * axis_dir
dist_to_axis <- sqrt(sum((as.numeric(point) - closest)^2))
if (dist_to_axis <= radius) {
return(i) # Cylinder index
}
}
}
return(NA) # No containing cylinder found
}
##################### 3. Build aRchi object from point cloud ###################
# l <- 9
for (l in 1:length(valid_trees)){
segment_stats <- data.frame(Tree = numeric(),
Segment = numeric(),
Length = numeric(),
Max_Deviation = numeric(),
Class = character(),
Start_Z = numeric(), End_Z = numeric(),
Diameter = numeric(),
Diameter_noBark = numeric(),
Diameter_class = character(),
FirstBranch_height = numeric(),
radial_variance = numeric(),
volume = numeric(),
# Has_Branch = logical(),
Branch_Count = numeric())
# empty list for the final segments
final_segments <- list()
#i <- 2
slice_size <- 0.1
### 3.1 Read data and clean
data <- read.csv(valid_trees[[l]])
# remove unneccesary columns
data[,4:15] <- NULL
# convert to .las
las <- LAS(data)
# set tree ID
tree_i <- as.numeric(str_extract(valid_trees[[l]], "\\d+"))
# filter outliers to correct possible errors in clustering
las <- classify_noise(las, sor(10,3))
las <- filter_poi(las, Classification != 18)
### 3.2 Build aRchi object
archi <- build_aRchi()
archi <- add_pointcloud(archi, point_cloud = las)
### 3.3 skeletonize aRchi object and add radius
archi <- skeletonize_pc(archi, D = 1, cl_dist = 0.3, max_d = 1.5,
progressive = TRUE)
### 3.4 Add radius to aRchi object
archi <- add_radius(archi, sec_length = 0.5, by_axis = TRUE,
method = "median")
### 3.5 Calculate paths of the aRchi object
archi_test <- Make_Path(archi)
### 3.6 Clean the QSM table
Clean_QSM(archi_test, threshold = 0.1, plotresult = FALSE)
### 3.7 Get branch heights
fork_heights <- ForkRateWithHeights(archi_test)
### 3.8 Extract QSM table
qsm_table <- archi_test@QSM
############ 4. Identify main stem (axis_ID == 1) and extract points ###########
### 4.1 subset the QSM table for main axis (axisID = 1)
main_stem <- subset(qsm_table, axis_ID == 1)
### 4.2 Extract start/end coordinates of main stem cylinders
main_stem_points <- rbind(
as.matrix(main_stem[, c("startX", "startY", "startZ")]),
as.matrix(main_stem[, c("endX", "endY", "endZ")])
)
### 4.3 Remove duplicates (if needed)
main_stem_points <- unique(main_stem_points)
# crown_points <- unique(crown_points)
# # Plot main stem axis to check for correctness
# plot <- scatterplot3d(main_stem_points,
#               color = "red",
#               pch = 16,
#               main = "Main Stem Axis",
#               xlab = "X", ylab = "Y", zlab = "Z")
#
# # Add original point cloud in background (grey)
# original_points <- as.matrix(archi@pointcloud@data[, c("X", "Y", "Z")])
# plot$points3d(original_points,
#               color = "grey")
### 4.4 get all "stem" points from original cloud
# Get original point cloud as a matrix
pc <- as.matrix(archi@pointcloud@data[, c("X", "Y", "Z")])
# generate empty matrix
in_main_axis <- rep(FALSE, nrow(pc))
# check if points are within the determined main axis cylinders
for (m in seq_len(nrow(main_stem))) {
cyl <- main_stem[m, ]
start <- as.numeric(c(cyl$startX, cyl$startY, cyl$startZ))
end <- as.numeric(c(cyl$endX, cyl$endY, cyl$endZ))
radius <- cyl$radius_cyl
axis_vec <- end - start
axis_len <- sqrt(sum(axis_vec^2))
if (axis_len < 1e-6) next  # skip degenerate cylinders
mask <- points_in_cylinder(pc, start, end,
max_radius = radius+0.1, min_radius = 0,
buffer = 0)
cat("Cylinder", m, "selected", sum(mask), "points\n")
in_main_axis <- in_main_axis | mask
}
# gather main axis points
stem_points <- pc[in_main_axis, ]
# cat("Total main axis points found:", nrow(main_axis_points), "\n")
############################# 5. Segment stem points ###########################
### 5.1 PCA for main stem axis
# find the dominant direction of the data which corresponds with the general
# orientation of the stem, enabling to analyze the trees shape independently
# of its initial orientation in the data set.
# Principal component analysis
pca <- prcomp(stem_points, center = TRUE)
axis_vector <- pca$rotation[,1]
stem_center <- colMeans(stem_points)
# Project stem points onto PCA axis to simplify curvature analysis and allow
# to sort points by height.
projected_points <- apply(stem_points, 1, function(pt) {
t <- sum((pt - stem_center) * axis_vector)
stem_center + t * axis_vector
})
projected_points <- t(projected_points)
### 5.2 Sort stem points by height for segmentation ##
sorted_indices <- order(stem_points[,3])  # Sort by Z (height)
stem_sorted <- stem_points[sorted_indices, ]
projected_sorted <- projected_points[sorted_indices, ]
### 5.3 Compute local curvature ##
deviations <- stem_sorted[,1:2] - projected_sorted[,1:2]  # XY-plane dev.
signed_curvature <- deviations[,1] * axis_vector[2] -
deviations[,2] * axis_vector[1]  # Signed curvature in 2D
smooth_curvature <- function(curvature, window = 5) {
filter(curvature, rep(1 / window, window), sides = 2)
}
# Apply smoothing
# smoothed_curvature <- smooth_curvature(signed_curvature, window = 5)
### 5.4 Segment the stem into sections with constant curvature sign
# Points where curvature sign changes
# change_points <- which(diff(sign(smoothed_curvature)) != 0)
# without smoothing
change_points <- which(diff(sign(signed_curvature)) != 0)
# Start and end of segments
segment_indices <- c(1, change_points, nrow(stem_sorted))
# Initialize a new list of segment start indices
merged_segment_indices <- c(segment_indices[1])
n <- 2
# segment the stem
while (n < length(segment_indices)) {
start_idx <- segment_indices[n]
segment_length <- 0
j <- n  # Keep track of a separate index for merging
while (j < length(segment_indices) &&
segment_length < min_segment_length) {
j <- j + 1
if (j > length(segment_indices))
break  # Prevent out-of-bounds indexing
end_idx <- segment_indices[j]
segment_length <- abs(stem_sorted[end_idx, 3] - stem_sorted[start_idx, 3])
}
# Find the closest allowed segment length (â‰¥ 3m)
possible_lengths <- allowed_lengths[allowed_lengths >= segment_length]
if (length(possible_lengths) > 0 & segment_length >= 3) {
final_segments <- rbind(final_segments, c(start_idx, end_idx))
}
n <- j  # Move to the next unmerged segment
}
# Convert to a proper list of indices
merged_segment_indices <- do.call(rbind, final_segments[,1])
merged_segment_indices <- unique(merged_segment_indices)
# Assign new segment labels
segment_labels <- rep(0, nrow(stem_sorted))
# Convert segment labels to positive integers
segment_labels <- as.integer(segment_labels) + 1  # Offset to avoid zeros
### 5.6 Compute segment parameters
# initialize lists for export
las_segments_list <- list()
las_centerlines_list <- list()
mid_slices_list <- list()
mid_circles_list <- list()
# find center line of each stem segment and calculate parameters
for (o in 1:(length(merged_segment_indices) - 1)) {
segment_i <- stem_sorted[merged_segment_indices[o]:
merged_segment_indices[o + 1], ]
# initialize centerline dataframe
centerline <- data.frame(Z = numeric(), Xc = numeric(), Yc = numeric())
# Define height slices
slice_heights <- seq(min(segment_i[, 3]), max(segment_i[, 3]), by = 0.1)
# loop through slices
for (h in slice_heights) {
slice <- subset(segment_i, segment_i[, 3] >= h - 0.1 &
segment_i[, 3] < h + 0.1)
if (nrow(slice) > 3) {
# Ensure enough points for fitting
circle <- fitSS(slice)
center <- cbind(circle$par[[1]], circle$par[[2]])
centerline <- rbind(centerline,
data.frame(Z = h,
Xc = center[1, 1],
Yc = center[1, 2]))
}
}
# Create LAS data with RGB attributes for segment
las_data <- data.frame(X = segment_i[, 1],
Y = segment_i[, 2],
Z = segment_i[, 3])
# Create LAS data with RGB attributes for center line
las_data2 <- data.frame(X = centerline$Xc,
Y = centerline$Yc,
Z = centerline$Z)
# # filter for outliers in data frame
# Q1_x <- quantile(las_data2$X, .25)
# Q3_x <- quantile(las_data2$X, .75)
# IQR_x <- IQR(las_data2$X)
# las_data2 <- subset(las_data2,
#                     las_data2$X > (Q1_x - 1.5 * IQR_x) &
#                       las_data2$X < (Q3_x + 1.5 * IQR_x))
# filter outliers with boxplot method
outliers_las_data2_x <- boxplot.stats(las_data2$X)$out
outliers_las_data2_y <- boxplot.stats(las_data2$Y)$out
outliers_las_data2_z <- boxplot.stats(las_data2$Z)$out
las_data2 <- las_data2[!(las_data2$X %in% outliers_las_data2_x |las_data2$Y %in% outliers_las_data2_y | las_data2$Z %in% outliers_las_data2_z),]
las_data2 <- subset(las_data2, X >= 0 & Y >= 0 & Z >= 0)
las_segment <- LAS(las_data)
las_centerline <- LAS(las_data2)
las_segments_list[[o]] <- las_segment
las_centerlines_list[[o]] <- las_centerline
# compute segment parameters
segment_start <- merged_segment_indices[o]
segment_end <- merged_segment_indices[o + 1]
if (is.na(segment_start) | is.na(segment_end)) {
# print(paste("Warning: NA values found in segment indices at row", i))
next  # Skip this segment
}
# calculate segment length
segment_length <- abs(stem_sorted[segment_end, 3] -
stem_sorted[segment_start, 3])
repeat {
start_slice <- subset(segment_i,
segment_i[, 3] >= stem_sorted[segment_start, 3] &
segment_i[, 3] <
(stem_sorted[segment_start, 3] + slice_size))
# Check if enough points are selected or window is too large
if (nrow(start_slice) >= min_points ||
slice_size >= max_window) {
break
}
# Increase window size incrementally
slice_size <- slice_size + 0.05
}
# calculate segment diameter at the start of the segment
start_circle <- fitSS(start_slice)
diameter_start <- start_circle[[1]][3] * 2
# exclude segments with a smaller starting diameter than 15cm
# if (diameter_start < 0.15) {
#   segment_crown <- rbind(segment_crown, segment_i)
#   next
# }
repeat {
mid_z <- (stem_sorted[segment_end, 3] +
stem_sorted[segment_start, 3]) / 2
mid_slice <- subset(segment_i,
segment_i[, 3] >= (mid_z - slice_size) &
segment_i[, 3] < (mid_z + slice_size))
# Check if enough points are selected or window is too large
if (nrow(mid_slice) >= min_points ||
slice_size >= max_window) {
break
}
# Increase window size incrementally (e.g., by 0.05 m)
slice_size <- slice_size + 0.05
}
mid_circle <- fitSS(mid_slice)
diameter <- mid_circle[[1]][3] * 2
# calculate diameter without bark
diameter_noBark <- if (diameter <= 0.41) {
diameter - 0.01
} else {
diameter - 0.02
}
# diameter class
diameter_class <- diameter_classification(diameter_noBark)
mid_slices_list[[o]] <- mid_slice
mid_circles_list[[o]] <- mid_circle
# calculate Curvature as deviation from a straight line
if (nrow(centerline) > 2) {
# Ensure there are enough points
# First and last points of centerline
P1 <- as.numeric(centerline[1, c("Xc", "Yc", "Z")])
P2 <- as.numeric(centerline[nrow(centerline), c("Xc", "Yc", "Z")])
# Compute distances of each centerline point to the line P1-P2
distances <- sapply(1:nrow(centerline), function(j) {
P <- as.numeric(centerline[j, c("Xc", "Yc", "Z")])
# Vector representations
v <- P2 - P1  # Line direction vector
w <- P - P1   # Vector from P1 to P
# Projection of w onto v
projection_factor <- sum(w * v) / sum(v * v)
projection <- P1 + projection_factor * v  # Closest point on the line
# Perpendicular distance
sqrt(sum((P - projection)^2))
})
# Maximum deviation
max_curvature <- max(distances, na.rm = TRUE)
}
# calculate radial variance for each segment
radial_variance <- compute_radial_variance(mid_slice, mid_circle[[1]][1],
mid_circle[[1]][2])
# calculate volume of segment (fm)
# segment_i_df <- as.data.frame(segment_i)  # Ensure it's a data frame
# segment_i_df[, 1:3] <- sweep(segment_i_df[, 1:3], 2,
#                              colMeans(segment_i_df[, 1:3]), "-")
# ashape <- ashape3d(as.matrix(segment_i_df), alpha = 1)
# fm <- volume_ashape3d(ashape)
fm <- pi * (diameter_noBark/2)^2 * as.numeric(segment_length)
branches <- sum(fork_heights[c(3:length(fork_heights))] >=
stem_sorted[segment_start, 3] &
fork_heights[c(3:length(fork_heights))] <
stem_sorted[segment_end, 3])
if(is.na(branches)){branches <- 0}
# rvr classification
class <- rvr_classification(segment_length, max_curvature,
diameter_noBark, branches)
# make a plot to vizualise the stem segment cross section
circlexy <- function(xyr, n = 180) {
theta = seq(0, 2 * pi, len = n)
cbind(xyr[1] + xyr[3] * cos(theta), xyr[2] + xyr[3] * sin(theta))
}
# collect segment stats in table
segment_stats <- rbind(segment_stats,
data.frame(
Tree = tree_i,
Segment = o,
Length = segment_length,
Max_Deviation = max_curvature,
Class = class,
Start_Z = stem_sorted[segment_start, 3],
End_Z = stem_sorted[segment_end, 3],
Diameter = diameter,
Diameter_noBark = diameter_noBark,
Diameter_class = diameter_class,
radial_variance = round(radial_variance, digits = 10),
volume = fm,
Branch_Count = branches
))
}
### 5.7 Plausibility check for segments
plausible <- logical(nrow(segment_stats))
plausible[1] <- TRUE  # First segment is always plausible
last_plausible <- 1
for (i in 2:nrow(segment_stats)) {
plausible[i] <- segment_stats$Diameter_noBark[i] <
segment_stats$Diameter_noBark[last_plausible] * 1.2
if(plausible[i]){
last_plausible <- i
}
}
for (i in length(plausible):1) {  # Iterate backwards!
if(plausible[i]) {
writeLAS(las_segments_list[[i]], paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]], paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
} else {
# Find next plausible segment
replacement <- NA
if (i < length(plausible)) {
for (j in (i+1):length(plausible)) {
if (isTRUE(plausible[j])) {
replacement <- j
break
}
}
}
if (!is.na(replacement)) {
segment_stats[i, "Diameter"] <- segment_stats[replacement, "Diameter"]
segment_stats[i, "Diameter_noBark"] <- if (segment_stats[replacement, "Diameter"] <= 0.41) {
segment_stats[replacement, "Diameter"] - 0.01
} else {
segment_stats[replacement, "Diameter"] - 0.02
}
segment_stats[i, "Diameter_class"] <- diameter_classification(segment_stats[i, "Diameter_noBark"])
segment_stats[i, "volume"] <- pi * (segment_stats[i, "Diameter_noBark"]/2)^2 * segment_stats[i, "Length"]
segment_stats[i, "Class"] <- rvr_classification(
segment_stats[i, "Length"],
segment_stats[i, "Max_Deviation"],
segment_stats[i, "Diameter_noBark"],
segment_stats[i, "Branch_Count"]
)
plausible[i] <- TRUE  # Optionally mark as plausible now
} else {
# Delete row i from all relevant objects
segment_stats <- segment_stats[-i, ]
plausible <- plausible[-i]
las_segments_list <- las_segments_list[-i]
las_centerlines_list <- las_centerlines_list[-i]
mid_slices_list <- mid_slices_list[-i]
mid_circles_list <- mid_circles_list[-i]
}
}
}
if(!isTRUE(plausible[length(plausible)])) {
segment_stats <- segment_stats[-length(plausible), ]
# If you have associated lists, remove the last element as well:
las_segments_list <- las_segments_list[-length(plausible)]
las_centerlines_list <- las_centerlines_list[-length(plausible)]
mid_slices_list <- mid_slices_list[-length(plausible)]
mid_circles_list <- mid_circles_list[-length(plausible)]
}
segment_stats_final <- rbind(segment_stats_final, segment_stats)
print(segment_stats_final)
cat("Total Stem Volume: ",
round(sum(segment_stats_final$volume),
digits = 3), "mÂ³", "\n" ,
"Volume Quality A: ",
round(sum(subset(segment_stats_final, segment_stats_final$Class == "A")$volume),
digits = 3), "mÂ³", "\n",
"Volume Quality B: ",
round(sum(subset(segment_stats_final, segment_stats_final$Class == "B")$volume),
digits = 3), "mÂ³", "\n",
"Volume Quality C: ",
round(sum(subset(segment_stats_final, segment_stats_final$Class == "C")$volume),
digits = 3), "mÂ³", "\n",
"Volume Quality D: ",
round(sum(subset(segment_stats_final, segment_stats_final$Class == "D")$volume),
digits = 3), "mÂ³")
########################### 6. Extract crown points ############################
crown_points <- anti_join(as.data.frame(pc), as.data.frame(stem_points))
crown_points <- as.matrix(crown_points)
crown_points <- subset(crown_points, crown_points[,3] >= segment_stats[nrow(segment_stats),]$Start_Z)
# plot3d(crown_points)
crown_las <- data.frame(X = crown_points[, 1],
Y = crown_points[, 2],
Z = crown_points[, 3])
crown_las <- LAS(crown_las)
# filter noise & outliers
crown_filtered <- classify_noise(crown_las, sor(10,3))
crown_filtered <- filter_poi(crown_filtered, Classification != 18)
# plot3d(crown_points)
# build the archi object
crown_archi <- build_aRchi()
crown_archi <- add_pointcloud(crown_archi, point_cloud = crown_filtered)
crown_archi <- skeletonize_pc(crown_archi, D = 0.5, cl_dist = 0.15, max_d = 0.5,
progressive = TRUE)
# plot(crown_archi)
crown_archi <- add_radius(crown_archi, sec_length = 0.5, by_axis = TRUE,
method = "median")
crown_qsm <- crown_archi@QSM
crown_wood_v <- sum(subset(crown_qsm,
radius_cyl >= 0.07 &
length >= 0.05 &
branching_order < 4 & #startZ >= segment_stats[length(segment_stats)]$End_Z
axis_ID != "1")$volume)
crown_fm <- crown_fm + crown_wood_v
########################### 7. Make Conclusion Table ###########################
# 1. Column: Quality Class
# 2. Column: Volume of the respective class
# summary <- segment_stats %>%
#   group_by(Class) %>%
#   summarize(Volume = sum(volume))
# print(segment_stats)
# sum(segment_stats$volume)
}
