j <- i  # Keep track of a separate index for merging
while (j < length(segment_indices) &&
segment_length < min_segment_length) {
j <- j + 1
if (j > length(segment_indices))
break  # Prevent out-of-bounds indexing
end_idx <- segment_indices[j]
segment_length <- abs(stem_sorted[end_idx, 3] - stem_sorted[start_idx, 3])
}
# Find the closest allowed segment length (≥ 3m)
possible_lengths <- allowed_lengths[allowed_lengths >= segment_length]
if (length(possible_lengths) > 0 & segment_length >= 3) {
final_segments <- rbind(final_segments, c(start_idx, end_idx))
}
i <- j  # Move to the next unmerged segment
}
# Convert to a proper list of indices
merged_segment_indices <- do.call(rbind, final_segments[,1])
merged_segment_indices <- unique(merged_segment_indices)
# Assign new segment labels
segment_labels <- rep(0, nrow(stem_sorted))
# Convert segment labels to positive integers
segment_labels <- as.integer(segment_labels) + 1  # Offset to avoid zeros
### 5.6 Compute segment parameters
# initialize lists for export
las_segments_list <- list()
las_centerlines_list <- list()
mid_slices_list <- list()
mid_circles_list <- list()
# find center line of each stem segment and calculate parameters
for (i in 1:(length(merged_segment_indices) - 1)) {
segment_i <- stem_sorted[merged_segment_indices[i]:
merged_segment_indices[i + 1], ]
# initialize centerline dataframe
centerline <- data.frame(Z = numeric(), Xc = numeric(), Yc = numeric())
# Define height slices
slice_heights <- seq(min(segment_i[, 3]), max(segment_i[, 3]), by = 0.1)
# loop through slices
for (h in slice_heights) {
slice <- subset(segment_i, segment_i[, 3] >= h - 0.1 &
segment_i[, 3] < h + 0.1)
if (nrow(slice) > 3) {
# Ensure enough points for fitting
circle <- fitSS(slice)
center <- cbind(circle$par[[1]], circle$par[[2]])
centerline <- rbind(centerline,
data.frame(Z = h,
Xc = center[1, 1],
Yc = center[1, 2]))
}
}
# Create LAS data with RGB attributes for segment
las_data <- data.frame(X = segment_i[, 1],
Y = segment_i[, 2],
Z = segment_i[, 3])
# Create LAS data with RGB attributes for center line
las_data2 <- data.frame(X = centerline$Xc,
Y = centerline$Yc,
Z = centerline$Z)
# filter for outliers in data frame
Q1_x <- quantile(las_data2$X, .25)
Q3_x <- quantile(las_data2$X, .75)
IQR_x <- IQR(las_data2$X)
las_data2 <- subset(las_data2,
las_data2$X > (Q1_x - 1.5 * IQR_x) &
las_data2$X < (Q3_x + 1.5 * IQR_x))
las_segment <- LAS(las_data)
las_centerline <- LAS(las_data2)
las_segments_list[[i]] <- las_segment
las_centerlines_list[[i]] <- las_centerline
# compute segment parameters
segment_start <- merged_segment_indices[i]
segment_end <- merged_segment_indices[i + 1]
if (is.na(segment_start) | is.na(segment_end)) {
# print(paste("Warning: NA values found in segment indices at row", i))
next  # Skip this segment
}
# calculate segment length
segment_length <- abs(stem_sorted[segment_end, 3] -
stem_sorted[segment_start, 3])
repeat {
start_slice <- subset(segment_i,
segment_i[, 3] >= stem_sorted[segment_start, 3] &
segment_i[, 3] <
(stem_sorted[segment_start, 3] + slice_size))
# Check if enough points are selected or window is too large
if (nrow(start_slice) >= min_points ||
slice_size >= max_window) {
break
}
# Increase window size incrementally
slice_size <- slice_size + 0.05
}
# calculate segment diameter at the start of the segment
start_circle <- fitSS(start_slice)
diameter_start <- start_circle[[1]][3] * 2
# exclude segments with a smaller starting diameter than 15cm
if (diameter_start < 0.15) {
segment_crown <- rbind(segment_crown, segment_i)
next
}
repeat {
mid_z <- (stem_sorted[segment_end, 3] +
stem_sorted[segment_start, 3]) / 2
mid_slice <- subset(segment_i,
segment_i[, 3] >= (mid_z - slice_size) &
segment_i[, 3] < (mid_z + slice_size))
# Check if enough points are selected or window is too large
if (nrow(mid_slice) >= min_points ||
slice_size >= max_window) {
break
}
# Increase window size incrementally (e.g., by 0.05 m)
slice_size <- slice_size + 0.05
}
mid_circle <- fitSS(mid_slice)
diameter <- mid_circle[[1]][3] * 2
# calculate diameter without bark
diameter_noBark <- if (diameter <= 0.41) {
diameter - 0.01
} else {
diameter - 0.02
}
# diameter class
diameter_class <- diameter_classification(diameter_noBark)
mid_slices_list[[i]] <- mid_slice
mid_circles_list[[i]] <- mid_circle
# calculate Curvature as deviation from a straight line
if (nrow(centerline) > 2) {
# Ensure there are enough points
# First and last points of centerline
P1 <- as.numeric(centerline[1, c("Xc", "Yc", "Z")])
P2 <- as.numeric(centerline[nrow(centerline), c("Xc", "Yc", "Z")])
# Compute distances of each centerline point to the line P1-P2
distances <- sapply(1:nrow(centerline), function(j) {
P <- as.numeric(centerline[j, c("Xc", "Yc", "Z")])
# Vector representations
v <- P2 - P1  # Line direction vector
w <- P - P1   # Vector from P1 to P
# Projection of w onto v
projection_factor <- sum(w * v) / sum(v * v)
projection <- P1 + projection_factor * v  # Closest point on the line
# Perpendicular distance
sqrt(sum((P - projection)^2))
})
# Maximum deviation
max_curvature <- max(distances, na.rm = TRUE)
}
# calculate radial variance for each segment
radial_variance <- compute_radial_variance(mid_slice, mid_circle[[1]][1],
mid_circle[[1]][2])
# calculate volume of segment (fm)
segment_i_df <- as.data.frame(segment_i)  # Ensure it's a data frame
segment_i_df[, 1:3] <- sweep(segment_i_df[, 1:3], 2,
colMeans(segment_i_df[, 1:3]), "-")
ashape <- ashape3d(as.matrix(segment_i_df), alpha = 1)
fm <- volume_ashape3d(ashape)
branches <- sum(fork_heights[c(3:length(fork_heights))] >=
stem_sorted[segment_start, 3] &
fork_heights[c(3:length(fork_heights))] <
stem_sorted[segment_end, 3])
# rvr classification
class <- rvr_classification(segment_length, max_curvature,
diameter_noBark, branches)
# make a plot to vizualise the stem segment cross section
circlexy <- function(xyr, n = 180) {
theta = seq(0, 2 * pi, len = n)
cbind(xyr[1] + xyr[3] * cos(theta), xyr[2] + xyr[3] * sin(theta))
}
# collect segment stats in table
segment_stats <- rbind(
segment_stats,
data.frame(
Tree = tree_i,
Segment = i,
Length = segment_length,
Max_Deviation = max_curvature,
Class = class,
Start_Z = stem_sorted[segment_start, 3],
End_Z = stem_sorted[segment_end, 3],
Diameter = diameter,
Diameter_noBark = diameter_noBark,
Diameter_class = diameter_class,
radial_variance = round(radial_variance, digits = 10),
volume = fm,
Branch_Count = branches
)
)
}
segment_stats
### 5.7 Plausibility check for segments
plausible <- logical(nrow(segment_stats))
plausible[1] <- TRUE  # First segment is always plausible
for (i in 2:nrow(segment_stats)) {
plausible[i] <- segment_stats$Diameter_noBark[i] <
segment_stats$Diameter_noBark[i - 1] * 1.2
}
plausible
# Only export/plot plausible segments
for (i in plausible) {
if(i == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (i+1 == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
}
}
segment_stats[i,]$Diameter
segment_stats
segment_stats[i,]
i
i == TRUE
plausible
# Only export/plot plausible segments
for (i in length(plausible)) {
if(plausible[i] == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (i+1 == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
}
}
segment_stats
# Only export/plot plausible segments
for (i in length(plausible)) {
if(plausible[i] == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (plausible[i+1] == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
}
}
# Only export/plot plausible segments
for (i in length(plausible)) {
if(plausible[i] == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (plausible[i+1] == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
} else {break}
}
# Only export/plot plausible segments
for (i in length(plausible)) {
if(plausible[i] == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (plausible[i+1] == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
} else break
}
# Only export/plot plausible segments
for (i in length(plausible)-1) {
if(plausible[i] == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (plausible[i+1] == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
} else break
}
segment_stats
segment_stats[i,]
plausible
# Only export/plot plausible segments
for (i in length(plausible)) {
if(plausible[i] == TRUE){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else if (i != length(plausible) & plausible[i+1] == TRUE){
segment_stats[i,]$Diameter <- segment_stats[i+1]$Diameter
segment_stats[i,]$Diameter_noBark <- if (segment_stats[i,]$Diameter <= 0.41) {
segment_stats[i,]$Diameter - 0.01
} else {
segment_stats[i,]$Diameter - 0.02
}
segment_stats[i,]$Diameter_class <- diameter_classification(segment_stats[i,]$Diameter_noBark)
segment_stats[i,]$volume <- pi * (segment_stats[i,]$Diameter_noBark/2)^2 *segment_stats[i,]$Length
} else break
}
segment_stats
segment_stats[i,]$Diameter
# Only export/plot plausible segments
for (i in seq_along(plausible)) {
if(plausible[i]){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else {
# Find next plausible segment (look ahead)
replacement <- NA
for(j in (i+1):length(plausible)) {
if(plausible[j]) {
replacement <- j
break
}}
if (!is.na(replacement)){
segment_stats[i, "Diameter"] <- segment_stats[replacement, "Diameter"]
segment_stats[i, "Diameter_noBark"] <- if(segment_stats[replacement, "Diameter"] <= 0.41) {
segment_stats[replacement, "Diameter"] - 0.01
} else {
segment_stats[replacement, "Diameter"] - 0.02
}
segment_stats[i, "Diameter_class"] <- diameter_classification(segment_stats[i, "Diameter_noBark"])
segment_stats[i, "volume"] <- pi * (segment_stats[i, "Diameter_noBark"]/2)^2 * segment_stats[i, "Length"]
}
}
}
# Only export/plot plausible segments
for (i in seq_along(plausible)) {
if(plausible[i]){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else {
# Find next plausible segment (look ahead)
replacement <- NA
for(j in (i+1):length(plausible)) {
if(isTRUA(plausible[j])) {
replacement <- j
break
}}
if (!is.na(replacement)){
segment_stats[i, "Diameter"] <- segment_stats[replacement, "Diameter"]
segment_stats[i, "Diameter_noBark"] <- if(segment_stats[replacement, "Diameter"] <= 0.41) {
segment_stats[replacement, "Diameter"] - 0.01
} else {
segment_stats[replacement, "Diameter"] - 0.02
}
segment_stats[i, "Diameter_class"] <- diameter_classification(segment_stats[i, "Diameter_noBark"])
segment_stats[i, "volume"] <- pi * (segment_stats[i, "Diameter_noBark"]/2)^2 * segment_stats[i, "Length"]
}
}
}
# Only export/plot plausible segments
for (i in seq_along(plausible)) {
if(plausible[i]){
writeLAS(las_segments_list[[i]],
paste("tree_", tree_i, "_segment_", i, ".las"))
writeLAS(las_centerlines_list[[i]],
paste("tree_", tree_i, "_centerline_", i, ".las"))
plot(
mid_slices_list[[i]],
asp = 1,
main = paste("Centre cross-section of segment ", i),
sub = paste("Diameter: ", round(segment_stats$Diameter_noBark[i], 3), "m")
)
lines(circlexy(mid_circles_list[[i]]$par))
}else {
# Find next plausible segment (look ahead)
replacement <- NA
for(j in (i+1):length(plausible)) {
if(isTRUE(plausible[j])) {
replacement <- j
break
}}
if (!is.na(replacement)){
segment_stats[i, "Diameter"] <- segment_stats[replacement, "Diameter"]
segment_stats[i, "Diameter_noBark"] <- if(segment_stats[replacement, "Diameter"] <= 0.41) {
segment_stats[replacement, "Diameter"] - 0.01
} else {
segment_stats[replacement, "Diameter"] - 0.02
}
segment_stats[i, "Diameter_class"] <- diameter_classification(segment_stats[i, "Diameter_noBark"])
segment_stats[i, "volume"] <- pi * (segment_stats[i, "Diameter_noBark"]/2)^2 * segment_stats[i, "Length"]
}
}
}
segment_stats
if(!isTRUE(plausible[length(plausible)])) {
segment_stats <- segment_stats[-length(plausible), ]
# If you have associated lists, remove the last element as well:
las_segments_list <- las_segments_list[-length(plausible)]
las_centerlines_list <- las_centerlines_list[-length(plausible)]
mid_slices_list <- mid_slices_list[-length(plausible)]
mid_circles_list <- mid_circles_list[-length(plausible)]
}
segment_stats
cat("Total Stem Volume: ",
round(sum(segment_stats$volume),
digits = 3), "m³", "\n" ,
"Volume Quality A: ",
round(sum(subset(segment_stats, segment_stats$Class == "A")$volume),
digits = 3), "m³", "\n",
"Volume Quality B: ",
round(sum(subset(segment_stats, segment_stats$Class == "B")$volume),
digits = 3), "m³", "\n",
"Volume Quality C: ",
round(sum(subset(segment_stats, segment_stats$Class == "C")$volume),
digits = 3), "m³", "\n",
"Volume Quality D: ",
round(sum(subset(segment_stats, segment_stats$Class == "D")$volume),
digits = 3), "m³")
